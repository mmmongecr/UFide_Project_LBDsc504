--SC504 Lenguajes de base de datos
--Proyecto final
--Grupo #
--Proyecto de Move Bakery


--==================================
-- CONEXIONES Y CREACION DE USUARIOS
--==================================

-- Consultar contenedor actual
SELECT SYS_CONTEXT('USERENV', 'CON_NAME') AS current_container FROM DUAL;
/

-- Cambiar al contenedor de trabajo
ALTER SESSION SET CONTAINER = XEPDB1;
/

-- Consultar usuarios
SELECT USERNAME, ACCOUNT_STATUS, PROFILE FROM DBA_USERS;
/

-- Consultar tamaño del shared pool
SELECT NAME, VALUE 
FROM v$parameter
WHERE NAME = 'shared_pool_size';
/

-- Ajustar tamaño del shared pool desde sys
ALTER SYSTEM SET shared_pool_size = 512M SCOPE = BOTH;
/

-- Consultar modo de archivado
SELECT LOG_MODE FROM v$DATABASE;
/

-- Redo logs actuales
SELECT A.GROUP#, B.MEMBER,
       A.BYTES/1024/1024 AS SIZE_MB,
       A.STATUS, A.ARCHIVED
FROM v$LOG A, v$LOGFILE B
WHERE A.GROUP# = B.GROUP#;
/

-- Crear Tablespace permanente
CREATE TABLESPACE PERM_MOVE_BAKERY_TBS
DATAFILE 'C:\ORACLE\ORADATA\XE\PERM_MOVE_BAKERY_TBS.DBF' SIZE 500M
AUTOEXTEND ON NEXT 50M MAXSIZE UNLIMITED;
/

-- Crear Tablespace temporal
CREATE TEMPORARY TABLESPACE TEMP_MOVE_BAKERY_TBS
TEMPFILE 'C:\ORACLE\ORADATA\XE\TEMP_MOVE_BAKERY_TBS.DBF' SIZE 500M
AUTOEXTEND ON NEXT 10M MAXSIZE 1G;
/

-- Crear Tablespace UNDO
CREATE UNDO TABLESPACE UNDO_MOVE_BAKERY_TBS
DATAFILE 'C:\ORACLE\ORADATA\XE\UNDO_MOVE_BAKERY_TBS.DBF' SIZE 100M
AUTOEXTEND ON NEXT 10M MAXSIZE 1G;
/

-- Asignar TBS UNDO por defecto
ALTER SYSTEM SET UNDO_TABLESPACE = UNDO_MOVE_BAKERY_TBS;
/

-- Verificar Tablespaces
SELECT TABLESPACE_NAME, CONTENTS, STATUS FROM DBA_TABLESPACES;
/

--Crear usuario principal
CREATE USER MOVE_BAKERY IDENTIFIED BY "BAK3R1"
DEFAULT TABLESPACE PERM_MOVE_BAKERY_TBS
TEMPORARY TABLESPACE TEMP_MOVE_BAKERY_TBS
QUOTA UNLIMITED ON PERM_MOVE_BAKERY_TBS;
/

-- Asignar privilegios básicos
GRANT CONNECT, RESOURCE TO MOVE_BAKERY;
GRANT CREATE SESSION TO MOVE_BAKERY;
/

-- Crear roles
CREATE ROLE super_administrator;
/

-- Privilegios para cada rol
GRANT CONNECT, RESOURCE, DBA TO super_administrator;
/

-- Asignar roles a usuarios
GRANT super_administrator TO MOVE_BAKERY;
/

--Funciones
--Crear funcion de verificar password
CREATE OR REPLACE FUNCTION PASSWORD_VERIFY_MOVE_BAKERY_FUNC(
  USERNAME VARCHAR2,
  PASSWORD VARCHAR2,
  OLD_PASSWORD VARCHAR2
) RETURN BOOLEAN IS
BEGIN
  -- Longitud mínima
  IF LENGTH(PASSWORD) < 16 THEN
    RAISE_APPLICATION_ERROR(-20001, 'La contraseña debe tener al menos 16 caracteres');
  END IF;

  -- Mayúsculas
  IF NOT REGEXP_LIKE(PASSWORD, '[A-Z]') THEN
    RAISE_APPLICATION_ERROR(-20002, 'Debe incluir al menos una letra mayúscula');
  END IF;

  -- Minúsculas
  IF NOT REGEXP_LIKE(PASSWORD, '[a-z]') THEN
    RAISE_APPLICATION_ERROR(-20003, 'Debe incluir al menos una letra minúscula');
  END IF;

  -- Números
  IF NOT REGEXP_LIKE(PASSWORD, '[0-9]') THEN
    RAISE_APPLICATION_ERROR(-20004, 'Debe incluir al menos un número');
  END IF;

  -- Caracter especial
  IF NOT REGEXP_LIKE(PASSWORD, '[^A-Za-z0-9]') THEN
    RAISE_APPLICATION_ERROR(-20005, 'Debe incluir al menos un carácter especial');
  END IF;

  RETURN TRUE;
END PASSWORD_VERIFY_MOVE_BAKERY_FUNC;
/

--Crear perfiles de seguridad
CREATE PROFILE SECURITY_PROFILE_MOVE_BAKERY LIMIT
  SESSIONS_PER_USER 1
  IDLE_TIME 40
  FAILED_LOGIN_ATTEMPTS 3
  PASSWORD_LOCK_TIME 3/24  -- 3 horas bloqueado
  PASSWORD_REUSE_MAX 4
  PASSWORD_VERIFY_FUNCTION PASSWORD_VERIFY_MOVE_BAKERY_FUNC;
/

SELECT SYS_CONTEXT('USERENV', 'CON_NAME') AS current_container FROM dual;

-- Asignar perfil a usuarios
ALTER USER MOVE_BAKERY PROFILE SECURITY_PROFILE_MOVE_BAKERY;
/

-- Ver Usuarios y roles
SELECT USERNAME, DEFAULT_TABLESPACE, TEMPORARY_TABLESPACE, PROFILE 
FROM DBA_USERS
WHERE USERNAME IN ('MOVE_BAKERY');
/

-- Ver Roles y sus privilegios
SELECT * FROM DBA_ROLE_PRIVS WHERE GRANTEE IN ('MOVE_BAKERY');
/

-- Ver Tablespaces disponibles
SELECT TABLESPACE_NAME, CONTENTS, STATUS FROM DBA_TABLESPACES;
/


--=========================
-- CREACION DE TABLAS
--=========================
CREATE TABLE "category" (
  "id" NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "name" VARCHAR2(255),
  "description" VARCHAR2(255),
  "vat_percentage" NUMBER(5,2) NOT NULL
)TABLESPACE PERM_MOVE_BAKERY_TBS;
/

CREATE TABLE "location" (
  "id" NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "province" VARCHAR2(255),
  "canton"   VARCHAR2(255),
  "district" VARCHAR2(255)
)TABLESPACE PERM_MOVE_BAKERY_TBS;
/

CREATE TABLE "user" (
  "id" NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "name" VARCHAR2(255),
  "first_surname"  VARCHAR2(255),
  "second_surname" VARCHAR2(255),
  "username" VARCHAR2(20),
  "user_type" VARCHAR2(20),
  "email" VARCHAR2(255),
  "password" VARCHAR2(255),
  "status" VARCHAR2(50),
  "dob" DATE,
  "profile_picture_path" VARCHAR2(1024),
  "created_at" TIMESTAMP DEFAULT SYSTIMESTAMP,
  "updated_at" TIMESTAMP DEFAULT SYSTIMESTAMP
)TABLESPACE PERM_MOVE_BAKERY_TBS;
/

-- modificacion para unicidades (no son FKs) para agregar uniques en username y email
ALTER TABLE "user" ADD CONSTRAINT "uk_user_username" UNIQUE ("username");
/

ALTER TABLE "user" ADD CONSTRAINT "uk_user_email"    UNIQUE ("email");
/

CREATE TABLE "directory" (
  "id" NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "phone" VARCHAR2(50),
  "user_id" NUMBER
)TABLESPACE PERM_MOVE_BAKERY_TBS;
/

CREATE TABLE "addresses" (
  "id" NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "other_signs" VARCHAR2(255),
  "favorite" CHAR(1) DEFAULT 'N' CHECK ("favorite" IN ('Y','N')),
  "location_id" NUMBER,
  "user_id" NUMBER
)TABLESPACE PERM_MOVE_BAKERY_TBS;
/

-- =========================
-- PRODUCTOS / INVENTARIO / PROMOS
-- =========================
CREATE TABLE "products" (
  "id" NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "name" VARCHAR2(255),
  "description" VARCHAR2(255),
  "price" NUMBER(10,2) NOT NULL,
  "image_path" VARCHAR2(1024),
  "category_id" NUMBER,
  "manufacturing_date" DATE,
  "expiration_date" DATE
)TABLESPACE PERM_MOVE_BAKERY_TBS;
/

CREATE TABLE "deals" (
  "id" NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "name" VARCHAR2(255),
  "quantity" NUMBER,
  "discount" NUMBER(5,2),
  "promotion_limit" NUMBER,
  "status" VARCHAR2(255)
)TABLESPACE PERM_MOVE_BAKERY_TBS;
/

CREATE TABLE "inventory" (
  "id" NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "batch" VARCHAR2(255),
  "quantity" NUMBER,
  "status" VARCHAR2(255),
  "best_before_date" DATE,
  "product_id" NUMBER,
  "deal_id" NUMBER
)TABLESPACE PERM_MOVE_BAKERY_TBS;
/

-- =========================
-- PAGOS
-- =========================
CREATE TABLE "payment_method" (
  "id" NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "type" VARCHAR2(255),
  "description" VARCHAR2(255)
)TABLESPACE PERM_MOVE_BAKERY_TBS;
/

CREATE TABLE "user_payment_method" (
  "id" NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "user_id" NUMBER NOT NULL,
  "payment_method_id" NUMBER NOT NULL,
  "cardholder_name" VARCHAR2(255),
  "favorite" CHAR(1) DEFAULT 'N' CHECK ("favorite" IN ('Y','N')),
  "account_number_token" VARCHAR2(255),
  "expiration_date" DATE
)TABLESPACE PERM_MOVE_BAKERY_TBS;
/

CREATE TABLE "payments" (
  "id" NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "amount" NUMBER(10,2),
  "date" DATE,
  "payment_method_id" NUMBER,
  "type" VARCHAR2(255)
)TABLESPACE PERM_MOVE_BAKERY_TBS;
/

-- =========================
-- ORDENES / DETALLES / COMPRAS / FACTURAS
-- =========================
CREATE TABLE "orders" (
  "id" NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "user_id" NUMBER,
  "order_date" TIMESTAMP DEFAULT SYSTIMESTAMP,
  "total_amount" NUMBER(10,2),
  "payment_method_id" NUMBER,
  "address_id" NUMBER,
  "status" VARCHAR2(50)
)TABLESPACE PERM_MOVE_BAKERY_TBS;
/

CREATE TABLE "order_details" (
  "id" NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "order_id" NUMBER,
  "product_id" NUMBER,
  "quantity" NUMBER,
  "unit_price" NUMBER(10,2)
)TABLESPACE PERM_MOVE_BAKERY_TBS;
/

CREATE TABLE "purchase_order" (
  "id" NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "user_id" NUMBER,
  "payment_method_id" NUMBER,
  "shipping_address_id" NUMBER
)TABLESPACE PERM_MOVE_BAKERY_TBS;
/

CREATE TABLE "purchase_order_products" (
  "id" NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "inventory_id" NUMBER,
  "quantity" NUMBER,
  "purchase_order_id" NUMBER
)TABLESPACE PERM_MOVE_BAKERY_TBS;
/

CREATE TABLE "invoice" (
  "id" NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "status" VARCHAR2(255),
  "payment_id" NUMBER,
  "discount" NUMBER(5,2),
  "subtotal" NUMBER(10,2),
  "vat_percentage" NUMBER(5,2),
  "total" NUMBER(10,2),
  "purchase_order_id" NUMBER
)TABLESPACE PERM_MOVE_BAKERY_TBS;
/

-- =========================
-- LOGIN / AUDITORIA
-- =========================
CREATE TABLE "login" (
  "id" NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "time_stamp" TIMESTAMP DEFAULT SYSTIMESTAMP,
  "status" VARCHAR2(255),
  "user_id" NUMBER
)TABLESPACE PERM_MOVE_BAKERY_TBS;
/

--=====================
-- CREACION DE INDICES
--=====================
CREATE INDEX "ix_directory_user"          ON "directory"("user_id");
/
CREATE INDEX "ix_addresses_location"      ON "addresses"("location_id");
/
CREATE INDEX "ix_addresses_user"          ON "addresses"("user_id");
/
CREATE INDEX "ix_products_category"       ON "products"("category_id");
/
CREATE INDEX "ix_inventory_product"       ON "inventory"("product_id");
/
CREATE INDEX "ix_inventory_deal"          ON "inventory"("deal_id");
/
CREATE INDEX "ix_upm_user"                ON "user_payment_method"("user_id");
/
CREATE INDEX "ix_upm_payment_method"      ON "user_payment_method"("payment_method_id");
/
CREATE INDEX "ix_payments_payment_method" ON "payments"("payment_method_id");
/
CREATE INDEX "ix_orders_user"             ON "orders"("user_id");
/
CREATE INDEX "ix_orders_upm"              ON "orders"("payment_method_id");
/
CREATE INDEX "ix_orders_address"          ON "orders"("address_id");
/
CREATE INDEX "ix_od_order"                ON "order_details"("order_id");
/
CREATE INDEX "ix_od_product"              ON "order_details"("product_id");
/
CREATE INDEX "ix_po_user"                 ON "purchase_order"("user_id");
/
CREATE INDEX "ix_po_upm"                  ON "purchase_order"("payment_method_id");
/
CREATE INDEX "ix_po_address"              ON "purchase_order"("shipping_address_id");
/
CREATE INDEX "ix_pop_inventory"           ON "purchase_order_products"("inventory_id");
/
CREATE INDEX "ix_pop_purchase_ord"        ON "purchase_order_products"("purchase_order_id");
/
CREATE INDEX "ix_invoice_payment"         ON "invoice"("payment_id");
/
CREATE INDEX "ix_invoice_purchase_ord"    ON "invoice"("purchase_order_id");
/
CREATE INDEX "ix_login_user"              ON "login"("user_id");
/


--===========================================================
-- ANADIR A TODAS LAS TABLAS EL FOREIGN KEY EN ORDEN SEGURO
--===========================================================
-- DIRECTORY
ALTER TABLE "directory"
  ADD CONSTRAINT "fk_directory_user"
  FOREIGN KEY ("user_id") REFERENCES "user"("id");
/

-- ADDRESSES
ALTER TABLE "addresses"
  ADD CONSTRAINT "fk_addresses_location"
  FOREIGN KEY ("location_id") REFERENCES "location"("id");
  /
  
ALTER TABLE "addresses"
  ADD CONSTRAINT "fk_addresses_user"
  FOREIGN KEY ("user_id") REFERENCES "user"("id");
/

-- PRODUCTS
ALTER TABLE "products"
  ADD CONSTRAINT "fk_products_category"
  FOREIGN KEY ("category_id") REFERENCES "category"("id");
/

-- INVENTORY
ALTER TABLE "inventory"
  ADD CONSTRAINT "fk_inventory_product"
  FOREIGN KEY ("product_id") REFERENCES "products"("id");
  /
  
ALTER TABLE "inventory"
  ADD CONSTRAINT "fk_inventory_deal"
  FOREIGN KEY ("deal_id") REFERENCES "deals"("id");
/

-- USER_PAYMENT_METHOD
ALTER TABLE "user_payment_method"
  ADD CONSTRAINT "fk_upm_user"
  FOREIGN KEY ("user_id") REFERENCES "user"("id");
  /
  
ALTER TABLE "user_payment_method"
  ADD CONSTRAINT "fk_upm_payment_method"
  FOREIGN KEY ("payment_method_id") REFERENCES "payment_method"("id");
/

-- PAYMENTS
ALTER TABLE "payments"
  ADD CONSTRAINT "fk_payments_payment_method"
  FOREIGN KEY ("payment_method_id") REFERENCES "payment_method"("id");
/

-- ORDERS
ALTER TABLE "orders"
  ADD CONSTRAINT "fk_orders_user"
  FOREIGN KEY ("user_id") REFERENCES "user"("id");
  /
  
ALTER TABLE "orders"
  ADD CONSTRAINT "fk_orders_upm"
  FOREIGN KEY ("payment_method_id") REFERENCES "user_payment_method"("id");
  /
  
ALTER TABLE "orders"
  ADD CONSTRAINT "fk_orders_address"
  FOREIGN KEY ("address_id") REFERENCES "addresses"("id");
  /
  
-- ORDER_DETAILS
ALTER TABLE "order_details"
  ADD CONSTRAINT "fk_od_order"
  FOREIGN KEY ("order_id") REFERENCES "orders"("id");
  /
  
ALTER TABLE "order_details"
  ADD CONSTRAINT "fk_od_product"
  FOREIGN KEY ("product_id") REFERENCES "products"("id");
  /

-- PURCHASE_ORDER
ALTER TABLE "purchase_order"
  ADD CONSTRAINT "fk_po_user"
  FOREIGN KEY ("user_id") REFERENCES "user"("id");
  /
  
ALTER TABLE "purchase_order"
  ADD CONSTRAINT "fk_po_upm"
  FOREIGN KEY ("payment_method_id") REFERENCES "user_payment_method"("id");
  /
  
ALTER TABLE "purchase_order"
  ADD CONSTRAINT "fk_po_address"
  FOREIGN KEY ("shipping_address_id") REFERENCES "addresses"("id");
  /

-- PURCHASE_ORDER_PRODUCTS
ALTER TABLE "purchase_order_products"
  ADD CONSTRAINT "fk_pop_inventory"
  FOREIGN KEY ("inventory_id") REFERENCES "inventory"("id");
  /
  
ALTER TABLE "purchase_order_products"
  ADD CONSTRAINT "fk_pop_purchase_ord"
  FOREIGN KEY ("purchase_order_id") REFERENCES "purchase_order"("id");
  /
  
-- INVOICE
ALTER TABLE "invoice"
  ADD CONSTRAINT "fk_invoice_payment"
  FOREIGN KEY ("payment_id") REFERENCES "payments"("id");
  /
  
ALTER TABLE "invoice"
  ADD CONSTRAINT "fk_invoice_purchase_ord"
  FOREIGN KEY ("purchase_order_id") REFERENCES "purchase_order"("id");
  /

-- LOGIN
ALTER TABLE "login"
  ADD CONSTRAINT "fk_login_user"
  FOREIGN KEY ("user_id") REFERENCES "user"("id");
  /

--==============================================================================
-- MODIFICACION DE TABLAS PARA AREGARLE CAMPOS DE AUDITORIA POR TUPLA A CADA UNA
--==============================================================================
--category
ALTER TABLE "category"
ADD(
    "created_date" TIMESTAMP,
    "modified_date" TIMESTAMP,
    "created_by" VARCHAR2(100),
    "modified_by" VARCHAR2(100),
    "action" VARCHAR2(100)
);
/

--location
ALTER TABLE "location"
ADD(
    "created_date" TIMESTAMP,
    "modified_date" TIMESTAMP,
    "created_by" VARCHAR2(100),
    "modified_by" VARCHAR2(100),
    "action" VARCHAR2(100)
);
/

--user
ALTER TABLE "user"
ADD(
    "created_date" TIMESTAMP,
    "modified_date" TIMESTAMP,
    "created_by" VARCHAR2(100),
    "modified_by" VARCHAR2(100),
    "action" VARCHAR2(100)
);
/

--directory
ALTER TABLE "directory"
ADD(
    "created_date" TIMESTAMP,
    "modified_date" TIMESTAMP,
    "created_by" VARCHAR2(100),
    "modified_by" VARCHAR2(100),
    "action" VARCHAR2(100)
);
/

--addresses
ALTER TABLE "addresses"
ADD(
    "created_date" TIMESTAMP,
    "modified_date" TIMESTAMP,
    "created_by" VARCHAR2(100),
    "modified_by" VARCHAR2(100),
    "action" VARCHAR2(100)
);
/

--products
ALTER TABLE "products"
ADD(
    "created_date" TIMESTAMP,
    "modified_date" TIMESTAMP,
    "created_by" VARCHAR2(100),
    "modified_by" VARCHAR2(100),
    "action" VARCHAR2(100)
);
/

--deals
ALTER TABLE "deals"
ADD(
    "created_date" TIMESTAMP,
    "modified_date" TIMESTAMP,
    "created_by" VARCHAR2(100),
    "modified_by" VARCHAR2(100),
    "action" VARCHAR2(100)
);
/

--inventory
ALTER TABLE "inventory"
ADD(
    "created_date" TIMESTAMP,
    "modified_date" TIMESTAMP,
    "created_by" VARCHAR2(100),
    "modified_by" VARCHAR2(100),
    "action" VARCHAR2(100)
);
/

--payment_method
ALTER TABLE "payment_method"
ADD(
    "created_date" TIMESTAMP,
    "modified_date" TIMESTAMP,
    "created_by" VARCHAR2(100),
    "modified_by" VARCHAR2(100),
    "action" VARCHAR2(100)
);
/

--user_payment_method
ALTER TABLE "user_payment_method"
ADD(
    "created_date" TIMESTAMP,
    "modified_date" TIMESTAMP,
    "created_by" VARCHAR2(100),
    "modified_by" VARCHAR2(100),
    "action" VARCHAR2(100)
);
/

--payments
ALTER TABLE "payments"
ADD(
    "created_date" TIMESTAMP,
    "modified_date" TIMESTAMP,
    "created_by" VARCHAR2(100),
    "modified_by" VARCHAR2(100),
    "action" VARCHAR2(100)
);
/

--orders
ALTER TABLE "orders"
ADD(
    "created_date" TIMESTAMP,
    "modified_date" TIMESTAMP,
    "created_by" VARCHAR2(100),
    "modified_by" VARCHAR2(100),
    "action" VARCHAR2(100)
);
/

--order_details
ALTER TABLE "order_details"
ADD(
    "created_date" TIMESTAMP,
    "modified_date" TIMESTAMP,
    "created_by" VARCHAR2(100),
    "modified_by" VARCHAR2(100),
    "action" VARCHAR2(100)
);
/

--purchase_order
ALTER TABLE "purchase_order"
ADD(
    "created_date" TIMESTAMP,
    "modified_date" TIMESTAMP,
    "created_by" VARCHAR2(100),
    "modified_by" VARCHAR2(100),
    "action" VARCHAR2(100)
);
/

--purchase_order_products
ALTER TABLE "purchase_order_products"
ADD(
    "created_date" TIMESTAMP,
    "modified_date" TIMESTAMP,
    "created_by" VARCHAR2(100),
    "modified_by" VARCHAR2(100),
    "action" VARCHAR2(100)
);
/

--invoice
ALTER TABLE "invoice"
ADD(
    "created_date" TIMESTAMP,
    "modified_date" TIMESTAMP,
    "created_by" VARCHAR2(100),
    "modified_by" VARCHAR2(100),
    "action" VARCHAR2(100)
);
/

--login
ALTER TABLE "login"
ADD(
    "created_date" TIMESTAMP,
    "modified_date" TIMESTAMP,
    "created_by" VARCHAR2(100),
    "modified_by" VARCHAR2(100),
    "action" VARCHAR2(100)
);
/


--=====================================================================================
-- TRIGGERS PARA CADA TABLA PARA LA AUDITORIO POR TUPLA A CADA UNA PARA INSERT Y UPDATE
--=====================================================================================
--TRIGGER BEFORE INSERT PARA TABLA CATEGORY
CREATE OR REPLACE TRIGGER TRG_INSERT_CATEGORY
BEFORE INSERT ON "category"
FOR EACH ROW
BEGIN
:NEW."created_date" := SYSTIMESTAMP;
:NEW."created_by" := SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'INSERT';
END;
/

--TRIGGER BEFORE UPDATE PARA TABLA CATEGORY
CREATE OR REPLACE TRIGGER TRG_UPDATE_CATEGORY
BEFORE UPDATE ON "category"
FOR EACH ROW
BEGIN
:NEW."modified_date":= SYSTIMESTAMP;
:NEW."modified_by"  :=SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'UPDATE';
END;
/

--TRIGGER BEFORE INSERT PARA TABLA LOCATION
CREATE OR REPLACE TRIGGER TRG_INSERT_LOCATION
BEFORE INSERT ON "location"
FOR EACH ROW
BEGIN
:NEW."created_date" := SYSTIMESTAMP;
:NEW."created_by" := SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'INSERT';
END;
/

--TRIGGER BEFORE UPDATE PARA TABLA LOCATION
CREATE OR REPLACE TRIGGER TRG_UPDATE_LOCATION
BEFORE UPDATE ON "location"
FOR EACH ROW
BEGIN
:NEW."modified_date":= SYSTIMESTAMP;
:NEW."modified_by"  :=SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'UPDATE';
END;
/

--TRIGGER BEFORE INSERT PARA TABLA USER
CREATE OR REPLACE TRIGGER TRG_INSERT_USER
BEFORE INSERT ON "user"
FOR EACH ROW
BEGIN
:NEW."created_date" := SYSTIMESTAMP;
:NEW."created_by" := SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'INSERT';
END;
/

--TRIGGER BEFORE UPDATE PARA TABLA USER
CREATE OR REPLACE TRIGGER TRG_UPDATE_USER
BEFORE UPDATE ON "user"
FOR EACH ROW
BEGIN
:NEW."modified_date":= SYSTIMESTAMP;
:NEW."modified_by"  :=SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'UPDATE';
END;
/

--TRIGGER BEFORE INSERT PARA TABLA DIRECTORY
CREATE OR REPLACE TRIGGER TRG_INSERT_DIRECTORY
BEFORE INSERT ON "directory"
FOR EACH ROW
BEGIN
:NEW."created_date" := SYSTIMESTAMP;
:NEW."created_by" := SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'INSERT';
END;
/

--TRIGGER BEFORE UPDATE PARA TABLA DIRECTORY
CREATE OR REPLACE TRIGGER TRG_UPDATE_DIRECTORY
BEFORE UPDATE ON "directory"
FOR EACH ROW
BEGIN
:NEW."modified_date":= SYSTIMESTAMP;
:NEW."modified_by"  :=SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'UPDATE';
END;
/

--TRIGGER BEFORE INSERT PARA TABLA ADDRESSES
CREATE OR REPLACE TRIGGER TRG_INSERT_ADDRESSES
BEFORE INSERT ON "addresses"
FOR EACH ROW
BEGIN
:NEW."created_date" := SYSTIMESTAMP;
:NEW."created_by" := SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'INSERT';
END;
/

--TRIGGER BEFORE UPDATE PARA TABLA ADDRESSES
CREATE OR REPLACE TRIGGER TRG_UPDATE_ADDRESSES
BEFORE UPDATE ON "addresses"
FOR EACH ROW
BEGIN
:NEW."modified_date":= SYSTIMESTAMP;
:NEW."modified_by"  :=SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'UPDATE';
END;
/

--TRIGGER BEFORE INSERT PARA TABLA PRODUCTS
CREATE OR REPLACE TRIGGER TRG_INSERT_PRODUCTS
BEFORE INSERT ON "products"
FOR EACH ROW
BEGIN
:NEW."created_date" := SYSTIMESTAMP;
:NEW."created_by" := SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'INSERT';
END;
/

--TRIGGER BEFORE UPDATE PARA TABLA PRODUCTS
CREATE OR REPLACE TRIGGER TRG_UPDATE_PRODUCTS
BEFORE UPDATE ON "products"
FOR EACH ROW
BEGIN
:NEW."modified_date":= SYSTIMESTAMP;
:NEW."modified_by"  :=SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'UPDATE';
END;
/

--TRIGGER BEFORE INSERT PARA TABLA DEALS
CREATE OR REPLACE TRIGGER TRG_INSERT_DEALS
BEFORE INSERT ON "deals"
FOR EACH ROW
BEGIN
:NEW."created_date" := SYSTIMESTAMP;
:NEW."created_by" := SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'INSERT';
END;
/

--TRIGGER BEFORE UPDATE PARA TABLA DEALS
CREATE OR REPLACE TRIGGER TRG_UPDATE_DEALS
BEFORE UPDATE ON "deals"
FOR EACH ROW
BEGIN
:NEW."modified_date":= SYSTIMESTAMP;
:NEW."modified_by"  :=SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'UPDATE';
END;
/

--TRIGGER BEFORE INSERT PARA TABLA INVENTORY
CREATE OR REPLACE TRIGGER TRG_INSERT_INVENTORY
BEFORE INSERT ON "inventory"
FOR EACH ROW
BEGIN
:NEW."created_date" := SYSTIMESTAMP;
:NEW."created_by" := SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'INSERT';
END;
/

--TRIGGER BEFORE UPDATE PARA TABLA INVENTORY
CREATE OR REPLACE TRIGGER TRG_UPDATE_INVENTORY
BEFORE UPDATE ON "inventory"
FOR EACH ROW
BEGIN
:NEW."modified_date":= SYSTIMESTAMP;
:NEW."modified_by"  :=SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'UPDATE';
END;
/

--TRIGGER BEFORE INSERT PARA TABLA PAYMENT_METHOD
CREATE OR REPLACE TRIGGER TRG_INSERT_PAYMENT_METHOD
BEFORE INSERT ON "payment_method"
FOR EACH ROW
BEGIN
:NEW."created_date" := SYSTIMESTAMP;
:NEW."created_by" := SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'INSERT';
END;
/

--TRIGGER BEFORE UPDATE PARA TABLA PAYMENT_METHOD
CREATE OR REPLACE TRIGGER TRG_UPDATE_PAYMENT_METHOD
BEFORE UPDATE ON "payment_method"
FOR EACH ROW
BEGIN
:NEW."modified_date":= SYSTIMESTAMP;
:NEW."modified_by"  :=SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'UPDATE';
END;
/

--TRIGGER BEFORE INSERT PARA TABLA USER_PAYMENT_METHOD
CREATE OR REPLACE TRIGGER TRG_INSERT_USER_PAYMENT_METHOD
BEFORE INSERT ON "user_payment_method"
FOR EACH ROW
BEGIN
:NEW."created_date" := SYSTIMESTAMP;
:NEW."created_by" := SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'INSERT';
END;
/

--TRIGGER BEFORE UPDATE PARA TABLA USER_PAYMENT_METHOD
CREATE OR REPLACE TRIGGER TRG_UPDATE_USER_PAYMENT_METHOD
BEFORE UPDATE ON "user_payment_method"
FOR EACH ROW
BEGIN
:NEW."modified_date":= SYSTIMESTAMP;
:NEW."modified_by"  :=SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'UPDATE';
END;
/

--TRIGGER BEFORE INSERT PARA TABLA PAYMENTS
CREATE OR REPLACE TRIGGER TRG_INSERT_PAYMENTS
BEFORE INSERT ON "payments"
FOR EACH ROW
BEGIN
:NEW."created_date" := SYSTIMESTAMP;
:NEW."created_by" := SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'INSERT';
END;
/

--TRIGGER BEFORE UPDATE PARA TABLA PAYMENTS
CREATE OR REPLACE TRIGGER TRG_UPDATE_PAYMENTS
BEFORE UPDATE ON "payments"
FOR EACH ROW
BEGIN
:NEW."modified_date":= SYSTIMESTAMP;
:NEW."modified_by"  :=SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'UPDATE';
END;
/

--TRIGGER BEFORE INSERT PARA TABLA ORDERS
CREATE OR REPLACE TRIGGER TRG_INSERT_ORDERS
BEFORE INSERT ON "orders"
FOR EACH ROW
BEGIN
:NEW."created_date" := SYSTIMESTAMP;
:NEW."created_by" := SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'INSERT';
END;
/

--TRIGGER BEFORE UPDATE PARA TABLA ORDERS
CREATE OR REPLACE TRIGGER TRG_UPDATE_ORDERS
BEFORE UPDATE ON "orders"
FOR EACH ROW
BEGIN
:NEW."modified_date":= SYSTIMESTAMP;
:NEW."modified_by"  :=SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'UPDATE';
END;
/

--TRIGGER BEFORE INSERT PARA TABLA ORDER_DETAILS
CREATE OR REPLACE TRIGGER TRG_INSERT_ORDER_DETAILS
BEFORE INSERT ON "order_details"
FOR EACH ROW
BEGIN
:NEW."created_date" := SYSTIMESTAMP;
:NEW."created_by" := SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'INSERT';
END;
/

--TRIGGER BEFORE UPDATE PARA TABLA ORDER_DETAILS
CREATE OR REPLACE TRIGGER TRG_UPDATE_ORDER_DETAILS
BEFORE UPDATE ON "order_details"
FOR EACH ROW
BEGIN
:NEW."modified_date":= SYSTIMESTAMP;
:NEW."modified_by"  :=SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'UPDATE';
END;
/

--TRIGGER BEFORE INSERT PARA TABLA PURCHASE_ORDER
CREATE OR REPLACE TRIGGER TRG_INSERT_PURCHASE_ORDER
BEFORE INSERT ON "purchase_order"
FOR EACH ROW
BEGIN
:NEW."created_date" := SYSTIMESTAMP;
:NEW."created_by" := SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'INSERT';
END;
/

--TRIGGER BEFORE UPDATE PARA TABLA PURCHASE_ORDER
CREATE OR REPLACE TRIGGER TRG_UPDATE_PURCHASE_ORDER
BEFORE UPDATE ON "purchase_order"
FOR EACH ROW
BEGIN
:NEW."modified_date":= SYSTIMESTAMP;
:NEW."modified_by"  :=SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'UPDATE';
END;
/

--TRIGGER BEFORE INSERT PARA TABLA PURCHASE_ORDER_PRODUCTS
CREATE OR REPLACE TRIGGER TRG_INSERT_PURCHASE_ORDER_PRODUCTS
BEFORE INSERT ON "purchase_order_products"
FOR EACH ROW
BEGIN
:NEW."created_date" := SYSTIMESTAMP;
:NEW."created_by" := SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'INSERT';
END;
/

--TRIGGER BEFORE UPDATE PARA TABLA PURCHASE_ORDER_PRODUCTS
CREATE OR REPLACE TRIGGER TRG_UPDATE_PURCHASE_ORDER_PRODUCTS
BEFORE UPDATE ON "purchase_order_products"
FOR EACH ROW
BEGIN
:NEW."modified_date":= SYSTIMESTAMP;
:NEW."modified_by"  :=SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'UPDATE';
END;
/

--TRIGGER BEFORE INSERT PARA TABLA 
CREATE OR REPLACE TRIGGER TRG_INSERT_INVOICE
BEFORE INSERT ON "invoice"
FOR EACH ROW
BEGIN
:NEW."created_date" := SYSTIMESTAMP;
:NEW."created_by" := SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'INSERT';
END;
/

--TRIGGER BEFORE UPDATE PARA TABLA INVOICE
CREATE OR REPLACE TRIGGER TRG_UPDATE_INVOICE
BEFORE UPDATE ON "invoice"
FOR EACH ROW
BEGIN
:NEW."modified_date":= SYSTIMESTAMP;
:NEW."modified_by"  :=SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'UPDATE';
END;
/

--TRIGGER BEFORE INSERT PARA TABLA LOGIN
CREATE OR REPLACE TRIGGER TRG_INSERT_LOGIN
BEFORE INSERT ON "login"
FOR EACH ROW
BEGIN
:NEW."created_date" := SYSTIMESTAMP;
:NEW."created_by" := SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'INSERT';
END;
/

--TRIGGER BEFORE UPDATE PARA TABLA LOGIN
CREATE OR REPLACE TRIGGER TRG_UPDATE_LOGIN
BEFORE UPDATE ON "login"
FOR EACH ROW
BEGIN
:NEW."modified_date":= SYSTIMESTAMP;
:NEW."modified_by"  :=SYS_CONTEXT('USERENV', 'SESSION_USER'); --USUARIO BASE DE DATOS O USUARIO FRONT
:NEW."action" := 'UPDATE';
END;
/


--============================
-- FUNCTIONS *ESTEBAN
--=============================

-- Funcion para calcular el subtotal de orden
CREATE OR REPLACE FUNCTION fn_calculate_order_subtotal (p_order_id IN NUMBER)
RETURN NUMBER IS
    v_subtotal NUMBER := 0;
BEGIN
    SELECT NVL(SUM("quantity" * NVL("unit_price", 0)), 0)
    INTO v_subtotal
    FROM "order_details"
    WHERE "order_id" = p_order_id;

    RETURN v_subtotal;
END;
/

-- Funcion para obtener el estado de promociones
CREATE OR REPLACE FUNCTION fn_get_deal_status (p_deal_id IN NUMBER)
RETURN VARCHAR2 IS
    v_status   VARCHAR2(255);
    v_qty      NUMBER;
    v_limit    NUMBER;
BEGIN
    SELECT "status", "quantity", "promotion_limit"
    INTO v_status, v_qty, v_limit
    FROM "deals"
    WHERE "id" = p_deal_id;

    IF LOWER(v_status) = 'inactive' THEN
        RETURN 'INACTIVE';
    ELSIF v_qty >= NVL(v_limit, 0) AND v_limit > 0 THEN
        RETURN 'EXPIRED';
    ELSE
        RETURN 'ACTIVE';
    END IF;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 'NOT FOUND';
END;
/

-- Funcion para obtener el total de factura
CREATE OR REPLACE FUNCTION fn_get_invoice_total (p_invoice_id IN NUMBER)
RETURN NUMBER IS
    v_total NUMBER := 0;
BEGIN
    SELECT NVL("total", 0)
    INTO v_total
    FROM "invoice"
    WHERE "id" = p_invoice_id;

    RETURN v_total;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 0;
END;
/


--============================
-- STORAGE PROCEDURES *ESTEBAN
--=============================

-- SP para agregar direccion de usuarios
SET SERVEROUTPUT ON;
/

CREATE OR REPLACE PROCEDURE sp_add_user_address (
  p_user_id      IN NUMBER,
  p_location_id  IN NUMBER,
  p_other_signs  IN VARCHAR2,
  p_favorite     IN CHAR DEFAULT 'N'
) AS
BEGIN
  INSERT INTO "addresses"("other_signs", "favorite", "location_id", "user_id")
  VALUES (p_other_signs, p_favorite, p_location_id, p_user_id);

  DBMS_OUTPUT.PUT_LINE('La dirección se agregó correctamente para el usuario: ' || p_user_id);
END;
/

-- Ejecutar el procedimiento
EXEC sp_add_user_address(1, 2, '100 metros Norte del Parque Central', 'Y');
/

-- SP para listar productos del catalogo
SET SERVEROUTPUT ON;
/
CREATE OR REPLACE PROCEDURE sp_list_product_catalog AS
BEGIN
  FOR r IN (
    SELECT "id", "name", "price"
    FROM "products"
    ORDER BY "name"
  ) LOOP
    DBMS_OUTPUT.PUT_LINE('Producto no. ' || r."id" || ' - ' || r."name" || ' - CRC' || r."price");
  END LOOP;
END;
/

-- Ejecutar el procedimiento
EXEC sp_list_product_catalog;
/

-- SP para actualizar cantidad de orden
SET SERVEROUTPUT ON;
/
CREATE OR REPLACE PROCEDURE sp_update_order_detail_qty (
  p_order_detail_id IN NUMBER,
  p_new_qty         IN NUMBER
) AS
  v_unit_price NUMBER;
BEGIN
  --precio actual del detalle del producto
  SELECT "unit_price"
  INTO v_unit_price
  FROM "order_details"
  WHERE "id" = p_order_detail_id;
  --actualiza cantidad
  UPDATE "order_details"
  SET "quantity" = p_new_qty
  WHERE "id" = p_order_detail_id;

  DBMS_OUTPUT.PUT_LINE('Cantidad se actualizó a ' || p_new_qty ||
                       ' (con el precio unitario CRC' || v_unit_price || ')');
END;
/

-- Ejecutar el procedimiento para actualizar un registro
BEGIN
  sp_update_order_detail_qty(10, 3);
END;
/

-- SP para aplicar promocion de pedido
SET SERVEROUTPUT ON;
/
CREATE OR REPLACE PROCEDURE sp_apply_deal_to_order (
  p_order_id IN NUMBER,
  p_deal_id  IN NUMBER
) AS
  v_discount NUMBER;
BEGIN
  SELECT "discount" INTO v_discount
  FROM "deals"
  WHERE "id" = p_deal_id;

  UPDATE "order_details"
  SET "unit_price" = "unit_price" - ("unit_price" * v_discount / 100)
  WHERE "order_id" = p_order_id;

  DBMS_OUTPUT.PUT_LINE('Descuento del ' || v_discount || '% se aplicó al pedido no. ' || p_order_id);
END;
/

-- Ejecutar el procedimiento
EXEC sp_apply_deal_to_order(5, 2);
/

-- SP para finalizar compra de orden
SET SERVEROUTPUT ON;
/
CREATE OR REPLACE PROCEDURE sp_checkout_order (
  p_purchase_order_id IN NUMBER
) AS
  v_subtotal      NUMBER := 0;
  v_vat_percentage NUMBER := 13; --vat del 13%
  v_total         NUMBER := 0;
BEGIN
  SELECT SUM("quantity" * (
    SELECT "price"
    FROM "products"
    WHERE "id" = po."inventory_id"
  ))
  INTO v_subtotal
  FROM "purchase_order_products" po
  WHERE po."purchase_order_id" = p_purchase_order_id;

  v_total := v_subtotal + (v_subtotal * v_vat_percentage / 100);

  INSERT INTO "invoice"(
    "status",
    "subtotal",
    "vat_percentage",
    "total",
    "purchase_order_id"
  ) VALUES (
    'GENERATED',
    v_subtotal,
    v_vat_percentage,
    v_total,
    p_purchase_order_id
  );

  DBMS_OUTPUT.PUT_LINE('Se generó la factura para la orden de compra no. ' || p_purchase_order_id ||
                       ' | Subtotal: CRC' || v_subtotal ||
                       ' | IVA: ' || v_vat_percentage || '%' ||
                       ' | Total: CRC' || v_total);
END;
/

-- Ejecutar el procedimiento
EXEC sp_checkout_order(1);
/

--============================
-- TRIGGERS *ESTEBAN
--=============================
-- Trigger para calcular el IVA del 13% automatico
CREATE OR REPLACE TRIGGER trg_invoice_auto_vat_total
BEFORE INSERT OR UPDATE ON "invoice"
FOR EACH ROW
DECLARE
    v_vat NUMBER := 0.13;  -- IVA del 13%
    v_subtotal NUMBER := 0;
BEGIN
    --calcula el subtotal cuando no esta definido
    IF :NEW."subtotal" IS NULL THEN
        SELECT NVL(SUM("quantity" * NVL("unit_price", 0)), 0)
        INTO v_subtotal
        FROM "order_details"
        WHERE "order_id" = :NEW."purchase_order_id";
        :NEW."subtotal" := v_subtotal;
    END IF;

    --calcula el total con el iva
    :NEW."vat_percentage" := v_vat * 100;  --guarda el vat percentage
    :NEW."total" := ROUND(:NEW."subtotal" * (1 + v_vat), 2);
END;
/


--============================
-- CURSORS *ESTEBAN
--=============================

-- Cursor para revision y reportes de usuario
SET SERVEROUTPUT ON;
/

DECLARE
  CURSOR cur_user_orders IS
    SELECT "id", "username", "email", "status"
    FROM "user";
BEGIN
  DBMS_OUTPUT.PUT_LINE('---Reporte de usuarios---');
  FOR r IN cur_user_orders LOOP
    DBMS_OUTPUT.PUT_LINE('Id: ' || r."id" || 
                         ' | Usuario: ' || r."username" ||
                         ' | Email: ' || r."email" ||
                         ' | Estado: ' || r."status");
  END LOOP;
END;
/

-- Cursor para cerrar o renovar promociones
SET SERVEROUTPUT ON;
/

DECLARE
  CURSOR cur_deals_expiring_soon IS
    SELECT "id", "name", "quantity", "status"
    FROM "deals"
    WHERE "status" <> 'ACTIVE' OR "quantity" <= 0;

BEGIN
  DBMS_OUTPUT.PUT_LINE('---Promociones inactivas o para revisar---');
  FOR r IN cur_deals_expiring_soon LOOP
    DBMS_OUTPUT.PUT_LINE('Id: ' || r."id" ||
                         ' | Nombre: ' || r."name" ||
                         ' | Cantidad: ' || NVL(TO_CHAR(r."quantity"),'0') ||
                         ' | Estado: ' || r."status");
  END LOOP;
END;
/

-- Cursor para auditar intentos fallidos de logins
SET SERVEROUTPUT ON;
/

DECLARE
  CURSOR cur_failed_logins IS
    SELECT "id", "time_stamp", "status", "user_id"
    FROM "login"
    WHERE UPPER("status") <> 'SUCCESS';

BEGIN
  DBMS_OUTPUT.PUT_LINE('---Intentos fallidos del login---');
  FOR r IN cur_failed_logins LOOP
    DBMS_OUTPUT.PUT_LINE('Login Id: ' || r."id" ||
                         ' | Usuario Id: ' || r."user_id" ||
                         ' | Fecha: ' || TO_CHAR(r."time_stamp", 'YYYY-MM-DD HH24:MI:SS') ||
                         ' | Estado: ' || r."status");
  END LOOP;
END;
/


--===============  
--OBJETOS - CAMILA ALFARO
--===============  
  ----------------------------------------------------------------------------------------------
    --FUNCIONES CAMILA
  ----------------------------------------------------------------------------------------------
SET SERVEROUTPUT ON
---SAVEPOINT mb_start;
  
  --fn_get_user_default_address
/*DirecciÃ³n favorita (si no hay favorita, devuelve la primera; si no hay ninguna: NULL) */
CREATE OR REPLACE FUNCTION fn_get_user_default_address(p_user_id NUMBER)
RETURN NUMBER IS
  v_addr_id NUMBER;
BEGIN
  SELECT x."id"
    INTO v_addr_id
    FROM (
      SELECT a."id"
      FROM "addresses" a
      WHERE a."user_id" = p_user_id
      ORDER BY CASE WHEN UPPER(TRIM(a."favorite")) = 'Y' THEN 0 ELSE 1 END, a."id"
    ) x
   WHERE ROWNUM = 1;
  RETURN v_addr_id;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN NULL;
END;
/
--fn_product_stock_available
--/*Stock disponible por producto (solo lo AVAILABLE) */
CREATE OR REPLACE FUNCTION fn_product_stock_available(p_product_id NUMBER)
RETURN NUMBER IS
  v_qty NUMBER := 0;
BEGIN
  SELECT NVL(SUM(i."quantity"),0)
    INTO v_qty
    FROM "inventory" i
   WHERE i."product_id" = p_product_id
     AND UPPER(NVL(i."status",'AVAILABLE')) = 'AVAILABLE';
  RETURN v_qty;
END;
/
--fn_calculate_vat
/*Multiplica monto * (vat/100)*/
CREATE OR REPLACE FUNCTION fn_calculate_vat(
    p_amount IN NUMBER,
    p_vat_percentage IN NUMBER
) RETURN NUMBER
IS
    v_vat_amount NUMBER;
BEGIN
    IF p_amount IS NULL OR p_vat_percentage IS NULL THEN
        RETURN 0;
    END IF;
    
    v_vat_amount := p_amount * (p_vat_percentage / 100);
    RETURN ROUND(v_vat_amount, 2);
    
EXCEPTION
    WHEN OTHERS THEN
        RETURN 0;
END fn_calculate_vat;
/

  ----------------------------------------------------------------------------------------------
    --PROCEDIMIENTOS ALMACENADOS CAMILA
  ----------------------------------------------------------------------------------------------
--sp_update_user_profile
--Actualizar informaciÃ³n de usuario
CREATE OR REPLACE PROCEDURE sp_update_user_profile(
  p_user_id              IN NUMBER,
  p_name                 IN VARCHAR2,
  p_first_surname        IN VARCHAR2,
  p_second_surname       IN VARCHAR2,
  p_username             IN VARCHAR2,
  p_email                IN VARCHAR2,
  p_status               IN VARCHAR2,
  p_profile_picture_path IN VARCHAR2
) AS
BEGIN
  UPDATE "user"
     SET "name"                 = p_name,
         "first_surname"        = p_first_surname,
         "second_surname"       = p_second_surname,
         "username"             = p_username,
         "email"                = p_email,
         "status"               = p_status,
         "profile_picture_path" = p_profile_picture_path,
         "updated_at"           = SYSTIMESTAMP
   WHERE "id" = p_user_id;
END;
/
--sp_set_favorite_payment_method
--Cambiar mÃ©todo de pago favorito
CREATE OR REPLACE PROCEDURE sp_set_favorite_payment_method(
  p_user_id IN NUMBER,
  p_upm_id  IN NUMBER
) AS
BEGIN
  UPDATE "user_payment_method" SET "favorite" = 'N' WHERE "user_id" = p_user_id;
  UPDATE "user_payment_method" SET "favorite" = 'Y' WHERE "id" = p_upm_id AND "user_id" = p_user_id;
END;
/

--sp_create_or_get_cart
--Busca o crea una orden status CART
CREATE OR REPLACE PROCEDURE sp_create_or_get_cart(
  p_user_id  IN  NUMBER,
  p_order_id OUT NUMBER
) AS
BEGIN
  BEGIN
    SELECT o."id" INTO p_order_id
      FROM "orders" o
     WHERE o."user_id" = p_user_id
       AND UPPER(NVL(o."status",'CART')) = 'CART'
       AND ROWNUM = 1;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      INSERT INTO "orders"("user_id","order_date","total_amount","status")
      VALUES(p_user_id, SYSTIMESTAMP, 0, 'CART')
      RETURNING "id" INTO p_order_id;
  END;
END;
/

--sp_reserve_inventory_for_order 
--Reserva stock - Marca unidades como RESERVED
CREATE OR REPLACE PROCEDURE sp_reserve_inventory_for_order(p_order_id IN NUMBER) AS
  CURSOR c_lines IS
    SELECT od."product_id", od."quantity" qty
      FROM "order_details" od
     WHERE od."order_id" = p_order_id;
  v_needed NUMBER;
  v_avail  NUMBER;
BEGIN
  FOR r IN c_lines LOOP
    v_needed := r.qty;
    v_avail  := fn_product_stock_available(r."product_id");
    IF v_avail < v_needed THEN
      RAISE_APPLICATION_ERROR(-20001,
        'Stock insuficiente product_id='||r."product_id"||
        ' necesita '||v_needed||' disponible '||v_avail);
    END IF;

    FOR lot IN (
      SELECT i."id", i."quantity"
        FROM "inventory" i
       WHERE i."product_id" = r."product_id"
         AND UPPER(NVL(i."status",'AVAILABLE')) = 'AVAILABLE'
       ORDER BY NVL(i."best_before_date", DATE '2999-12-31')
    ) LOOP
      EXIT WHEN v_needed <= 0;
      UPDATE "inventory" SET "status" = 'RESERVED' WHERE "id" = lot."id";
      v_needed := v_needed - NVL(lot."quantity",0);
    END LOOP;
  END LOOP;
END;
/


 --sp_generate_invoice
--Generar facturas/Crea invoice con totales calculados
CREATE OR REPLACE PROCEDURE sp_generate_invoice(
  p_order_id   IN  NUMBER,
  p_invoice_id OUT NUMBER
) AS
  v_subtotal  NUMBER := 0;
  v_vat_total NUMBER := 0;
  v_total     NUMBER := 0;
BEGIN
  SELECT NVL(SUM(od."quantity" * od."unit_price"),0)
    INTO v_subtotal
    FROM "order_details" od
   WHERE od."order_id" = p_order_id;

  SELECT NVL(SUM(
           (od."quantity" * od."unit_price") * NVL(c."vat_percentage",0) / 100
         ),0)
    INTO v_vat_total
    FROM "order_details" od
    JOIN "products"      p ON p."id" = od."product_id"
    LEFT JOIN "category" c ON c."id" = p."category_id"
   WHERE od."order_id" = p_order_id;

  v_total := v_subtotal + v_vat_total;

  INSERT INTO "invoice"("status","payment_id","discount","subtotal",
                        "vat_percentage","total","purchase_order_id")
  VALUES('PENDING', NULL, 0, v_subtotal, NULL, v_total, NULL)
  RETURNING "id" INTO p_invoice_id;

  UPDATE "orders" SET "total_amount" = v_total WHERE "id" = p_order_id;
END;
/

  ----------------------------------------------------------------------------------------------
    --TRIGGERS CAMILA
  ----------------------------------------------------------------------------------------------
  --trg_order_auto_total
  --Usa fn_calculate_order_total y actualiza order
CREATE OR REPLACE TRIGGER trg_order_auto_total
AFTER INSERT OR UPDATE ON "order_details"
FOR EACH ROW
DECLARE
    v_new_total NUMBER;
BEGIN
   
    SELECT NVL(SUM("quantity" * "unit_price"), 0)
    INTO v_new_total
    FROM "order_details"
    WHERE "order_id" = :NEW."order_id";  
    

    UPDATE "orders"
    SET "total_amount" = v_new_total     
    WHERE "id" = :NEW."order_id";        
    
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20006, 'Error al actualizar total de orden: ' || SQLERRM);
END trg_order_auto_total;
/

SELECT trigger_name, status, trigger_type
FROM user_triggers
WHERE trigger_name = 'TRG_ORDER_AUTO_TOTAL';

  ----------------------------------------------------------------------------------------------
    --CURSORES CAMILA
  ----------------------------------------------------------------------------------------------
  
--cur_low_stock_products
--Genera alertas o reposiciÃ³n
CREATE OR REPLACE PROCEDURE cur_low_stock_products(
  p_threshold IN NUMBER DEFAULT 10,
  p_cursor    OUT SYS_REFCURSOR
) AS
BEGIN
  OPEN p_cursor FOR
    SELECT p."id" AS product_id,
           p."name" AS product_name,
           NVL(SUM(i."quantity"),0) AS stock
      FROM "products" p
      LEFT JOIN "inventory" i ON i."product_id" = p."id"
         AND UPPER(NVL(i."status",'AVAILABLE')) IN ('AVAILABLE','RESERVED')
     GROUP BY p."id", p."name"
    HAVING NVL(SUM(i."quantity"),0) < p_threshold
     ORDER BY stock ASC;
END;
/


--cur_invoices_to_send
--Automatiza envÃ­o de facturas
CREATE OR REPLACE PROCEDURE cur_invoices_to_send(
  p_cursor OUT SYS_REFCURSOR
) AS
BEGIN
  OPEN p_cursor FOR
    SELECT "id","status","subtotal","total"
      FROM "invoice"
     WHERE UPPER(NVL("status",'PENDING')) = 'PENDING'
     ORDER BY "id" DESC;
END;
/

--cur_top_selling_products
--Ranking de productos vendidos
CREATE OR REPLACE PROCEDURE cur_top_selling_products(
  p_limit IN NUMBER DEFAULT 10,
  p_cursor OUT SYS_REFCURSOR
) AS
BEGIN
  OPEN p_cursor FOR
    SELECT *
      FROM (
        SELECT od."product_id",
               p."name" AS product_name,
               SUM(od."quantity") AS qty_sold,
               RANK() OVER (ORDER BY SUM(od."quantity") DESC) rnk
          FROM "order_details" od
          JOIN "products" p ON p."id" = od."product_id"
         GROUP BY od."product_id", p."name"
      )
     WHERE rnk <= NVL(p_limit,10)
     ORDER BY rnk;
END;
/

---=================
-- OBJETOS LUIS
---=================
--Creacion de procedimientos almacenados (Luis)
--1 Procedimiento para Registrar Intentos de Login
  CREATE OR REPLACE PROCEDURE sp_record_login_attempt (
    p_user_id IN NUMBER,
    p_status IN VARCHAR2
) AS
    v_user_exists NUMBER;
BEGIN
-- Verifica que el usuario existe
    SELECT COUNT(*) INTO v_user_exists 
    FROM "user" 
    WHERE "id" = p_user_id;
    
    IF v_user_exists = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Usuario no encontrado');
    END IF;
    
-- Inserta el registro de login
    INSERT INTO "login" ("user_id", "status", "time_stamp")
    VALUES (p_user_id, p_status, SYSTIMESTAMP);
    
    COMMIT;
    
    DBMS_OUTPUT.PUT_LINE('Intento de login registrado exitosamente');
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20002, 'Error al registrar intento de login: ' || SQLERRM);
END sp_record_login_attempt;
/  
 
--2  Procedimiento para Eliminar MEtodo de Pago
CREATE OR REPLACE PROCEDURE sp_remove_user_payment_method (
    p_payment_method_id IN NUMBER
) AS
    v_payment_in_use NUMBER;
    v_payment_exists NUMBER;
BEGIN
-- Verifica que el mEtodo de pago existe
    SELECT COUNT(*) INTO v_payment_exists 
    FROM "user_payment_method" 
    WHERE "id" = p_payment_method_id;
    
    IF v_payment_exists = 0 THEN
        RAISE_APPLICATION_ERROR(-20003, 'Método de pago no encontrado');
    END IF;
    
--  Verifica si el mÃ©todo de pago estÃ¡ siendo usado en Ã³rdenes activas
    SELECT COUNT(*) INTO v_payment_in_use
    FROM "orders" o
    WHERE o."payment_method_id" = p_payment_method_id
    AND o."status" NOT IN ('Entregado', 'Cancelado');
    
    IF v_payment_in_use > 0 THEN
        RAISE_APPLICATION_ERROR(-20004, 'No se puede eliminar: mÃ©todo de pago en uso en Ã³rdenes activas');
    END IF;
    
-- Eliminar el mÃ©todo de pago
    DELETE FROM "user_payment_method" 
    WHERE "id" = p_payment_method_id;
    
    COMMIT;
    
    DBMS_OUTPUT.PUT_LINE('MÃ©todo de pago eliminado exitosamente');
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20005, 'Error al eliminar mÃ©todo de pago: ' || SQLERRM);
END sp_remove_user_payment_method;
/
  
--3 Procedimiento para Agregar items a una Orden
CREATE OR REPLACE PROCEDURE sp_add_item_to_order (
    p_order_id IN NUMBER,
    p_product_id IN NUMBER,
    p_quantity IN NUMBER
) AS
    v_order_exists NUMBER;
    v_product_exists NUMBER;
    v_unit_price NUMBER;
    v_current_quantity NUMBER;
    v_inventory_id NUMBER;
BEGIN

-- Valida que la orden exista
    SELECT COUNT(*) INTO v_order_exists 
    FROM "orders" 
    WHERE "id" = p_order_id;
    
    IF v_order_exists = 0 THEN
        RAISE_APPLICATION_ERROR(-20006, 'Orden no encontrada');
    END IF;
    
-- Valida que el producto exista
    SELECT COUNT(*) INTO v_product_exists 
    FROM "products" 
    WHERE "id" = p_product_id;
    
    IF v_product_exists = 0 THEN
        RAISE_APPLICATION_ERROR(-20007, 'Producto no encontrado');
    END IF;
    
-- Obtiene el precio del producto
    SELECT "price" INTO v_unit_price 
    FROM "products" 
    WHERE "id" = p_product_id;
    
-- Verifica el stock disponible
    SELECT SUM("quantity") INTO v_current_quantity
    FROM "inventory"
    WHERE "product_id" = p_product_id 
    AND "status" = 'AVAILABLE'
    AND ("best_before_date" IS NULL OR "best_before_date" > SYSDATE);
    
    IF v_current_quantity IS NULL OR v_current_quantity < p_quantity THEN
        RAISE_APPLICATION_ERROR(-20008, 'Stock insuficiente. Disponible: ' || NVL(v_current_quantity, 0));
    END IF;
    
-- Inserta el order_details
    INSERT INTO "order_details" ("order_id", "product_id", "quantity", "unit_price")
    VALUES (p_order_id, p_product_id, p_quantity, v_unit_price);
    
-- Reserva el inventario
    UPDATE "inventory" 
    SET "quantity" = "quantity" - p_quantity,
        "status" = 'Reservado'
    WHERE "product_id" = p_product_id 
    AND "status" = 'AVAILABLE'
    AND ROWNUM = 1; -- Simplificado para el ejemplo
    
    COMMIT;
    
    DBMS_OUTPUT.PUT_LINE('Item agregado a la orden exitosamente');
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20009, 'Datos no encontrados para la operación');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Error al agregar item a la orden: ' || SQLERRM);
END sp_add_item_to_order;
/
  
--4 Procedimiento para Liberar Stock Reservado
CREATE OR REPLACE PROCEDURE sp_release_inventory_reservations (
    p_order_id IN NUMBER
) AS
    v_order_exists NUMBER;
    v_products_affected NUMBER;
BEGIN
    -- Verificar que la orden existe
    SELECT COUNT(*) INTO v_order_exists 
    FROM "orders" 
    WHERE "id" = p_order_id;
    
    IF v_order_exists = 0 THEN
        RAISE_APPLICATION_ERROR(-20011, 'Orden no encontrada');
    END IF;
    
    -- Liberar inventario reservado usando UPDATE directo con subconsulta
    UPDATE "inventory" inv
    SET "quantity" = "quantity" + (
        SELECT od."quantity"
        FROM "order_details" od
        WHERE od."order_id" = p_order_id
        AND od."product_id" = inv."product_id"
    ),
    "status" = 'Disponible'
    WHERE "product_id" IN (
        SELECT "product_id"
        FROM "order_details"
        WHERE "order_id" = p_order_id
    )
    AND "status" = 'Reservado';
    
    v_products_affected := SQL%ROWCOUNT;
    
    -- Marcar la orden como cancelada
    UPDATE "orders"
    SET "status" = 'Cancelado'
    WHERE "id" = p_order_id;
    
    COMMIT;
    
    DBMS_OUTPUT.PUT_LINE('Stock liberado exitosamente. Productos afectados: ' || v_products_affected);
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20012, 'Error al liberar stock: ' || SQLERRM);
END sp_release_inventory_reservations;
/

--5 Procedimiento para reponer stock de compras***
CREATE OR REPLACE PROCEDURE sp_restock_inventory_from_purchase (
    p_purchase_order_id IN NUMBER
) AS
    v_purchase_exists NUMBER;
    v_items_processed NUMBER;
    v_batch VARCHAR2(255);
BEGIN
   
-- Verifica que la orden de compra existe
    SELECT COUNT(*) INTO v_purchase_exists 
    FROM "purchase_order" 
    WHERE "id" = p_purchase_order_id;
    
    IF v_purchase_exists = 0 THEN
        RAISE_APPLICATION_ERROR(-20013, 'Orden de compra no encontrada');
    END IF;
    
-- Actualiza el inventario existente usando UPDATE con JOIN implÃ­cito
    UPDATE "inventory" inv
    SET "quantity" = "quantity" + (
        SELECT pop."quantity"
        FROM "purchase_order_products" pop
        WHERE pop."inventory_id" = inv."id"
        AND pop."purchase_order_id" = p_purchase_order_id
    ),
    "status" = 'AVAILABLE',
    "best_before_date" = SYSDATE + 30
    WHERE "id" IN (
        SELECT "inventory_id"
        FROM "purchase_order_products"
        WHERE "purchase_order_id" = p_purchase_order_id
    );
    
    v_items_processed := SQL%ROWCOUNT;
    
-- Inserta nuevos registros de inventario para items que no existen
    FOR rec IN (
        SELECT pop."inventory_id", pop."quantity", i."product_id"
        FROM "purchase_order_products" pop
        LEFT JOIN "inventory" i ON pop."inventory_id" = i."id"
        WHERE pop."purchase_order_id" = p_purchase_order_id
        AND i."id" IS NULL
    ) LOOP
        v_batch := 'LOTE_' || TO_CHAR(SYSDATE, 'YYYYMMDD') || '_' || rec."inventory_id";
        
        INSERT INTO "inventory" (
            "id", "batch", "quantity", "status", "best_before_date", 
            "product_id", "deal_id"
        ) VALUES (
            rec."inventory_id", v_batch, rec."quantity", 'AVAILABLE', 
            SYSDATE + 30, rec."product_id", NULL
        );
    END LOOP;
    
-- Actualiza el estado de la orden de compra
    UPDATE "purchase_order"
    SET "status" = 'COMPLETED'
    WHERE "id" = p_purchase_order_id;
    
    COMMIT;
    
    DBMS_OUTPUT.PUT_LINE('Stock repuesto exitosamente. Items procesados: ' || v_items_processed);
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20014, 'Error al reponer stock: ' || SQLERRM);
END sp_restock_inventory_from_purchase;
/

--Creacion de funciones 
--1 Funcion para Obtener MÃ©todo de Pago Favorito del Usuario
CREATE OR REPLACE FUNCTION fn_get_user_favorite_payment (
    p_user_id IN NUMBER
) RETURN NUMBER
AS
    v_favorite_payment_id NUMBER;
BEGIN

    SELECT "id"
    INTO v_favorite_payment_id
    FROM "user_payment_method"
    WHERE "user_id" = p_user_id
    AND "favorite" = 'Y'
    AND ROWNUM = 1; 
    
    RETURN v_favorite_payment_id;
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        BEGIN
            SELECT "id"
            INTO v_favorite_payment_id
            FROM "user_payment_method"
            WHERE "user_id" = p_user_id
            ORDER BY "id" DESC
            FETCH FIRST 1 ROW ONLY;
            
            RETURN v_favorite_payment_id;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                RETURN NULL;
        END;
    WHEN TOO_MANY_ROWS THEN
        SELECT "id"
        INTO v_favorite_payment_id
        FROM "user_payment_method"
        WHERE "user_id" = p_user_id
        AND "favorite" = 'Y'
        FETCH FIRST 1 ROW ONLY;
        
        RETURN v_favorite_payment_id;
    WHEN OTHERS THEN
        RETURN NULL;
END fn_get_user_favorite_payment;
/

--2 Funcion para Validar Disponibilidad de Producto
CREATE OR REPLACE FUNCTION fn_check_product_availability (
    p_product_id IN NUMBER,
    p_required_quantity IN NUMBER
) RETURN VARCHAR2
AS
    v_available_quantity NUMBER;
    v_is_available VARCHAR2(5); -- 'TRUE' o 'FALSE'
BEGIN
    
    SELECT NVL(SUM("quantity"), 0)
    INTO v_available_quantity
    FROM "inventory"
    WHERE "product_id" = p_product_id
    AND "status" = 'Disponible'
    AND ("best_before_date" IS NULL OR "best_before_date" > SYSDATE);
          IF v_available_quantity >= p_required_quantity THEN
        v_is_available := 'TRUE';
    ELSE
        v_is_available := 'FALSE';
    END IF;
    
    RETURN v_is_available;
    
EXCEPTION
    WHEN OTHERS THEN
        RETURN 'FALSE';
END fn_check_product_availability;
/

--3 Funcion para Obtener la Fecha del ultimo Pago
CREATE OR REPLACE FUNCTION fn_get_last_payment_date (
    p_user_id IN NUMBER DEFAULT NULL
) RETURN DATE
AS
    v_last_payment_date DATE;
BEGIN
    IF p_user_id IS NOT NULL THEN
        
        SELECT MAX(p."date")
        INTO v_last_payment_date
        FROM "payments" p
        JOIN "user_payment_method" upm ON p."payment_method_id" = upm."payment_method_id"
        WHERE upm."user_id" = p_user_id;
    ELSE
        
        SELECT MAX("date")
        INTO v_last_payment_date
        FROM "payments";
    END IF;
    
    RETURN v_last_payment_date;
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN NULL;
    WHEN OTHERS THEN
        RETURN NULL;
END fn_get_last_payment_date;
/


--=======================
--OBTEJOS KENDAL PICADO
--=======================
-- Procedimientos de almacenados - Kendal Picado
--Definir direcciÃ³n principal
CREATE OR REPLACE PROCEDURE sp_set_default_address(
    p_user_id IN NUMBER,
    p_address_id IN NUMBER
) AS
BEGIN
    -- Desmarcar todas las direcciones del usuario
    UPDATE "addresses"
    SET "favorite" = 'N'
    WHERE "user_id" = p_user_id;

    -- Marcar la direccin seleccionada como favorita
    UPDATE "addresses"
    SET "favorite" = 'Y'
    WHERE "id" = p_address_id
    AND "user_id" = p_user_id;

    COMMIT;
END sp_set_default_address;
/

SELECT * FROM "addresses" WHERE "user_id" = 1;

EXEC sp_set_default_address(1, 3)
/

-- Confirmar el cambio:
SELECT * FROM "addresses" WHERE "user_id" = 1;

-- 2. Detalle producto - Kendal Picado
CREATE OR REPLACE PROCEDURE sp_get_product_detail (
    p_product_id IN NUMBER,
    p_name      OUT "products"."name"%TYPE,
    p_price     OUT "products"."price"%TYPE,
    p_category  OUT "category"."name"%TYPE,
    p_total_stock OUT NUMBER
) AS
BEGIN
    SELECT p."name", p."price", c."name"
    INTO p_name, p_price, p_category
    FROM "products" p
    JOIN "category" c ON p."category_id" = c."id"
    WHERE p."id" = p_product_id; 

    SELECT NVL(SUM("quantity"), 0)
    INTO p_total_stock
    FROM "inventory"
    WHERE "product_id" = p_product_id
      AND "status" = 'Available';
END sp_get_product_detail;
/


-- 3. Eliminar Ã­tem
CREATE OR REPLACE PROCEDURE sp_remove_order_item (
    p_order_detail_id IN NUMBER
) AS
    v_order_id "order_details"."order_id"%TYPE;
    v_items_count NUMBER;
BEGIN
    -- 1. Obtener el ID de la orden antes de borrar el detalle
    SELECT "order_id"
    INTO v_order_id
    FROM "order_details"
    WHERE "id" = p_order_detail_id;

    -- 2. Eliminar la lnea del carrito (detalle)
    DELETE FROM "order_details"
    WHERE "id" = p_order_detail_id;

    -- 3. Verificar si quedan ms tems en la orden
    SELECT COUNT(*)
    INTO v_items_count
    FROM "order_details"
    WHERE "order_id" = v_order_id;

    IF v_items_count = 0 THEN
        -- Si la orden queda vacIa, se elimina la orden principal
        DELETE FROM "orders"
        WHERE "id" = v_order_id;
    ELSE
            UPDATE "orders"
            SET "total_amount" = fn_calculate_order_subtotal(v_order_id)
            WHERE "id" = v_order_id;
        
        UPDATE "orders"
        SET "total_amount" = "total_amount" - (SELECT "quantity" * "unit_price" FROM "order_details" WHERE "id" = p_order_detail_id)
        WHERE "id" = v_order_id;
    END IF;

    COMMIT;
END sp_remove_order_item;
/

-- 4. Expirar promociones
CREATE OR REPLACE PROCEDURE sp_expire_deals
AS
BEGIN
    
    UPDATE "deals"
    SET "status" = 'EXPIRED',
        "modified_date" = SYSTIMESTAMP,
        "modified_by" = SYS_CONTEXT('USERENV', 'SESSION_USER'),
        "action" = 'EXPIRE'
    WHERE "quantity" >= "promotion_limit"
      AND "promotion_limit" IS NOT NULL
      AND "status" <> 'EXPIRED';

    COMMIT;
END sp_expire_deals;
/


-- 5. Cancelar orden
CREATE OR REPLACE PROCEDURE sp_cancel_order (
    p_order_id IN NUMBER
) AS
    CURSOR c_order_items IS
        SELECT od."product_id", od."quantity"
        FROM "order_details" od
        WHERE od."order_id" = p_order_id;

    v_order_status "orders"."status"%TYPE;
    v_product_id   "order_details"."product_id"%TYPE;
    v_quantity     "order_details"."quantity"%TYPE;
BEGIN
    -- 1. Verificar el estado actual de la orden
    SELECT "status" INTO v_order_status
    FROM "orders"
    WHERE "id" = p_order_id;

    IF v_order_status NOT IN ('Cancelled', 'Delivered') THEN
    
        -- 2. Liberar Stock 
        OPEN c_order_items;
        LOOP
            FETCH c_order_items INTO v_product_id, v_quantity;
            EXIT WHEN c_order_items%NOTFOUND;

            UPDATE "inventory"
            SET "quantity" = "quantity" + v_quantity,
                "modified_date" = SYSTIMESTAMP,
                "modified_by" = SYS_CONTEXT('USERENV', 'SESSION_USER'),
                "action" = 'STOCK_RETURN_CANCEL'
            WHERE "product_id" = v_product_id
              AND "status" = 'Available'
              AND ROWNUM = 1; 

        END LOOP;
        CLOSE c_order_items;

        -- 3. cancelarorden y poner el monto en cero
        UPDATE "orders"
        SET "status" = 'Cancelled',
            "total_amount" = 0, 
            "modified_date" = SYSTIMESTAMP,
            "modified_by" = SYS_CONTEXT('USERENV', 'SESSION_USER'),
            "action" = 'CANCEL'
        WHERE "id" = p_order_id;
    END IF;

    COMMIT;
END sp_cancel_order;
/

-- FUNCIONES KENDAL PICADO
-- FUNCION 1 - Descuento
CREATE OR REPLACE FUNCTION fn_is_order_cancelable (
    p_order_id IN NUMBER
)
RETURN CHAR 
AS
    v_order_status "orders"."status"%TYPE;
BEGIN
    SELECT "status"
    INTO v_order_status
    FROM "orders"
    WHERE "id" = p_order_id;
    
    IF v_order_status IN ('Pending', 'Processing') THEN
        RETURN 'Y'; 
    ELSE
        RETURN 'N'; 
    END IF;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 'N'; 
    WHEN OTHERS THEN
        RETURN 'N';
END fn_is_order_cancelable;
/


-- FUNCION 3 - Orden cancelable

CREATE OR REPLACE FUNCTION fn_is_order_cancelable (
    p_order_id IN NUMBER
)
RETURN NUMBER 
AS
    v_order_status "orders"."status"%TYPE;
BEGIN
    SELECT "status"
    INTO v_order_status
    FROM "orders"
    WHERE "id" = p_order_id;
    
    IF v_order_status IN ('Pending', 'Processing') THEN
        RETURN 1; -- TRUE (Cancelable)
    ELSE
        RETURN 0;  --FALSE (No cancelable)
    END IF;

END fn_is_order_cancelable;
/

-- TRIGGERS - KENDAL PICADO
-- TRIGGER 1 - Evita cambios invÃ¡lidos en status
CREATE OR REPLACE TRIGGER trg_order_status_control
BEFORE UPDATE OF "status" ON "orders"
FOR EACH ROW
DECLARE
    e_invalid_status_change EXCEPTION;
    PRAGMA EXCEPTION_INIT(e_invalid_status_change, -20001);
    
    v_old_priority NUMBER;
    v_new_priority NUMBER;
BEGIN
    v_old_priority := CASE UPPER(:OLD."status")
                        WHEN 'PENDING' THEN 1
                        WHEN 'PROCESSING' THEN 2
                        WHEN 'IN TRANSIT' THEN 3
                        WHEN 'DELIVERED' THEN 4
                        WHEN 'CANCELLED' THEN 5
                        ELSE 0
                      END;

    v_new_priority := CASE UPPER(:NEW."status")
                        WHEN 'PENDING' THEN 1
                        WHEN 'PROCESSING' THEN 2
                        WHEN 'IN TRANSIT' THEN 3
                        WHEN 'DELIVERED' THEN 4
                        WHEN 'CANCELLED' THEN 5
                        ELSE 0
                      END;
                      
   
    IF :OLD."status" IN ('Delivered', 'Cancelled') THEN
        RAISE_APPLICATION_ERROR(-20001, 
            'ERROR: No se puede modificar (' || :OLD."status" || ').');
    END IF;

    IF :NEW."status" = 'Cancelled' THEN
        RETURN;
    END IF;

    IF v_new_priority <= v_old_priority OR v_new_priority = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 
            'ERROR: Transicin de estado invlida de ' || :OLD."status" || ' a ' || :NEW."status" || '.');
    END IF;

END trg_order_status_control;
/


-- CURSORES KENDAL PICADO
-- CURSOR 1 - Ãrdenes pendientes
CURSOR cur_pending_orders 
IS
    SELECT 
        o."id" AS order_id,
        o."user_id",
        o."total_amount",
        o."created_date",
        o."status"
    FROM 
        "orders" o
    WHERE 
        o."status" IN ('Pending', 'Processing') 
    ORDER BY 
        o."created_date" ASC;
/

-- CURSOR 2 - Facturas impagas
ALTER TABLE "payments" ADD ("invoice_id" NUMBER);
/
COMMIT;
SET SERVEROUTPUT ON;

DECLARE
    CURSOR cur_unpaid_invoices_test IS
        SELECT
            i."id" AS invoice_id,
            i."created_date",
            i."total" AS total_due, 
            NVL(SUM(p."amount"), 0) AS total_paid,
            (i."total" - NVL(SUM(p."amount"), 0)) AS pending_balance
        FROM
            "invoice" i
        LEFT JOIN
            "payments" p ON p."invoice_id" = i."id" -
        GROUP BY
            i."id", i."total", i."created_date"
        HAVING
            i."total" > NVL(SUM(p."amount"), 0)
        ORDER BY 
            i."created_date" ASC;
            
    r_invoice cur_unpaid_invoices_test%ROWTYPE;
    v_count NUMBER := 0;
BEGIN
    DBMS_OUTPUT.PUT_LINE('--- FACTURAS PENDIENTES DE PAGO ENCONTRADAS (CORREGIDO) ---');
    
    OPEN cur_unpaid_invoices_test;
    LOOP
        FETCH cur_unpaid_invoices_test INTO r_invoice;
        EXIT WHEN cur_unpaid_invoices_test%NOTFOUND;
        
        DBMS_OUTPUT.PUT_LINE('ID Factura: ' || r_invoice.invoice_id || 
                             ' | Total Adeudado: ' || r_invoice.total_due || 
                             ' | Total Pagado: ' || r_invoice.total_paid ||
                             ' | Saldo Pendiente: ' || r_invoice.pending_balance);
        v_count := v_count + 1;
    END LOOP;
    CLOSE cur_unpaid_invoices_test;
    
    DBMS_OUTPUT.PUT_LINE('--- Total de facturas impagas encontradas: ' || v_count || ' ---');
END;
/
-- CURSOR 3 - Reabastecimiento
SET SERVEROUTPUT ON;
DECLARE
    CURSOR cur_restock_test IS
        SELECT 
            p."id" AS product_id,
            p."name" AS product_name,
            
            (50 - i."quantity") AS quantity_to_order
        FROM 
            "products" p
        JOIN 
            "inventory" i ON p."id" = i."product_id" 
        WHERE
            i."quantity" <= 10 
            AND (50 - i."quantity") > 0;
            
    r_restock cur_restock_test%ROWTYPE;
    v_count NUMBER := 0;
    
BEGIN
    DBMS_OUTPUT.PUT_LINE('--- PRODUCTOS REQUIRIENDO REABASTECIMIENTO---');
    
    OPEN cur_restock_test;
    LOOP
        FETCH cur_restock_test INTO r_restock;
        EXIT WHEN cur_restock_test%NOTFOUND;
        
        DBMS_OUTPUT.PUT_LINE('ID Producto: ' || r_restock.product_id || 
                             ' | Nombre: ' || r_restock.product_name || 
                             ' | Cantidad a Ordenar: ' || r_restock.quantity_to_order);
        v_count := v_count + 1;
    END LOOP;
    CLOSE cur_restock_test;
    
    DBMS_OUTPUT.PUT_LINE('--- Total de productos a ordenar: ' || v_count || ' ---');
END;
/


--=========================
--OBJETOS MANUEL MORA
--=========================
-- ***************
-- ** FUNCIONES **
-- ***************
CREATE OR REPLACE FUNCTION fn_get_user_full_name (
    p_user_id IN NUMBER
) RETURN VARCHAR2 IS
    v_full_name VARCHAR2(600);
BEGIN
    SELECT TRIM("name" || ' ' || "first_surname" || ' ' || NVL("second_surname", ''))
      INTO v_full_name
      FROM "user"
     WHERE "id" = p_user_id;

    RETURN v_full_name;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN NULL;
END;
/

CREATE OR REPLACE FUNCTION fn_calculate_order_total (
    p_order_id IN NUMBER
) RETURN NUMBER IS
    v_subtotal NUMBER(10,2);
    v_discount NUMBER(10,2);
    v_vat_percentage NUMBER(5,2);
    v_total NUMBER(10,2);
BEGIN
    -- Calcular subtotal de lÃ­neas
    SELECT NVL(SUM("quantity" * "unit_price"), 0)
      INTO v_subtotal
      FROM "order_details"
     WHERE "order_id" = p_order_id;

    -- Obtener descuento e IVA guardados en la orden si existen
    SELECT NVL("discount", 0), NVL("vat_percentage", 0)
      INTO v_discount, v_vat_percentage
      FROM "orders"
     WHERE "id" = p_order_id;

    v_total := (v_subtotal - v_discount) + ((v_subtotal - v_discount) * v_vat_percentage / 100);

    RETURN ROUND(v_total, 2);
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 0;
END;
/

CREATE OR REPLACE FUNCTION fn_get_order_status (
    p_order_id IN NUMBER
) RETURN VARCHAR2 IS
    v_status VARCHAR2(50);
BEGIN
    SELECT "status"
      INTO v_status
      FROM "orders"
     WHERE "id" = p_order_id;

    RETURN v_status;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 'NOT_FOUND';
END;
/

-- ***************
-- ** Trigger **
-- ***************
CREATE TABLE "user_audit_log_simple" (
  "id"          NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "user_id"     NUMBER NOT NULL,
  "changes"     VARCHAR2(4000),
  "changed_at"  TIMESTAMP DEFAULT SYSTIMESTAMP,
  "changed_by"  VARCHAR2(255) DEFAULT SYS_CONTEXT('USERENV','SESSION_USER')
);
/

-- Funcion para dar formato a los cambios en la tabla user
CREATE OR REPLACE FUNCTION fn_add_user_change (
  p_changes IN VARCHAR2,
  p_col     IN VARCHAR2,
  p_old     IN VARCHAR2,
  p_new     IN VARCHAR2
) RETURN VARCHAR2 AS
  v_result VARCHAR2(4000);
BEGIN
  IF p_changes IS NOT NULL THEN
    v_result := p_changes || '; ';
  END IF;

  v_result := v_result || p_col || ': [' || NVL(p_old, 'NULL') || '] -> [' || NVL(p_new, 'NULL') || ']';
  RETURN v_result;
END;
/

CREATE OR REPLACE TRIGGER trg_user_audit_update_simple
BEFORE UPDATE ON "user"
FOR EACH ROW
DECLARE
  v_changes VARCHAR2(4000);
BEGIN
  -- Siempre actualiza la fecha de modificacion
  :NEW."updated_at" := SYSTIMESTAMP;

  -- Verifica los cambios
  IF NVL(:OLD."name", 'Â§') <> NVL(:NEW."name", 'Â§') THEN
    v_changes := fn_add_user_change(v_changes, 'name', :OLD."name", :NEW."name");
  END IF;

  IF NVL(:OLD."first_surname", 'Â§') <> NVL(:NEW."first_surname", 'Â§') THEN
    v_changes := fn_add_user_change(v_changes, 'first_surname', :OLD."first_surname", :NEW."first_surname");
  END IF;

  IF NVL(:OLD."second_surname", 'Â§') <> NVL(:NEW."second_surname", 'Â§') THEN
    v_changes := fn_add_user_change(v_changes, 'second_surname', :OLD."second_surname", :NEW."second_surname");
  END IF;

  IF NVL(:OLD."email", 'Â§') <> NVL(:NEW."email", 'Â§') THEN
    v_changes := fn_add_user_change(v_changes, 'email', :OLD."email", :NEW."email");
  END IF;

  IF NVL(:OLD."status", 'Â§') <> NVL(:NEW."status", 'Â§') THEN
    v_changes := fn_add_user_change(v_changes, 'status', :OLD."status", :NEW."status");
  END IF;

  -- Si hay cambios, los registra en la tabla de auditorÃ­a
  IF v_changes IS NOT NULL THEN
    INSERT INTO "user_audit_log_simple" ("user_id", "changes")
    VALUES (:OLD."id", v_changes);
  END IF;
END;
/

-- ***************
-- ** Cursores  **
-- ***************
-- Recorre todos los productos activos del catÃ¡logo
CURSOR cur_all_products IS
  SELECT 
    "id",
    "name",
    "description",
    "price",
    "category_id",
    "manufacturing_date",
    "expiration_date"
  FROM "products"
  ORDER BY "id";
/

-- Recorre todos los Items de una orden
CURSOR cur_order_items(p_order_id NUMBER) IS
  SELECT 
    od."id" AS order_detail_id,
    od."order_id",
    od."product_id",
    p."name" AS product_name,
    od."quantity",
    od."unit_price",
    (od."quantity" * od."unit_price") AS line_total
  FROM "order_details" od
  JOIN "products" p ON p."id" = od."product_id"
 WHERE od."order_id" = p_order_id;
/

-- Obtiene direcciones junto con provincia, canton y distrito
CURSOR cur_addresses_by_region IS
  SELECT 
    a."id" AS address_id,
    a."user_id",
    a."favorite",
    l."province",
    l."canton",
    l."district",
    a."other_signs"
  FROM "addresses" a
  JOIN "location" l ON l."id" = a."location_id"
  ORDER BY l."province", l."canton", l."district";
/

-- **********************
-- ** Store Procedures **
-- **********************
CREATE OR REPLACE PROCEDURE sp_register_user (
  p_name            IN  VARCHAR2,
  p_first_surname   IN  VARCHAR2,
  p_second_surname  IN  VARCHAR2,
  p_username        IN  VARCHAR2,
  p_email           IN  VARCHAR2,
  p_password_hash   IN  VARCHAR2,
  p_dob             IN  DATE,
  p_user_id         OUT NUMBER,
  p_code            OUT VARCHAR2,
  p_message         OUT VARCHAR2
) AS
BEGIN
  INSERT INTO "user" (
    "name", "first_surname", "second_surname", "username", "email", "password", "status", "dob", "created_at", "updated_at"
  ) VALUES (
    p_name, p_first_surname, p_second_surname, p_username, p_email, p_password_hash, 'ACTIVE', p_dob, SYSTIMESTAMP, SYSTIMESTAMP
  )
  RETURNING "id" INTO p_user_id;

  p_code    := 'OK';
  p_message := 'Usuario creado';
EXCEPTION
  WHEN DUP_VAL_ON_INDEX THEN
    p_code    := 'ERR_DUP';
    p_message := 'Username o email ya existen';
  WHEN OTHERS THEN
    p_code    := 'ERR';
    p_message := SQLERRM;
END;
/

CREATE OR REPLACE PROCEDURE sp_add_user_payment_method (
  p_user_id            IN  NUMBER,
  p_payment_method_id  IN  NUMBER,
  p_cardholder_name    IN  VARCHAR2,
  p_account_token      IN  VARCHAR2,
  p_expiration_date    IN  DATE,
  p_favorite           IN  CHAR,        -- 'Y'/'N'
  p_upm_id             OUT NUMBER,
  p_code               OUT VARCHAR2,
  p_message            OUT VARCHAR2
) AS
BEGIN
  IF p_favorite = 'Y' THEN
    UPDATE "user_payment_method"
       SET "favorite" = 'N'
     WHERE "user_id" = p_user_id
       AND "favorite" = 'Y';
  END IF;

  INSERT INTO "user_payment_method" (
    "user_id", "payment_method_id", "cardholder_name", "account_number_token", "expiration_date", "favorite"
  ) VALUES (
    p_user_id, p_payment_method_id, p_cardholder_name, p_account_token, p_expiration_date, NVL(p_favorite,'N')
  )
  RETURNING "id" INTO p_upm_id;

  p_code    := 'OK';
  p_message := 'Metodo de pago agregado';
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    p_code    := 'ERR_FK';
    p_message := 'Usuario o metodo de pago no existe';
  WHEN OTHERS THEN
    p_code    := 'ERR';
    p_message := SQLERRM;
END;
/

CREATE OR REPLACE PROCEDURE sp_search_products (
  p_search  IN  VARCHAR2,         -- parametro de entrada
  p_result  OUT SYS_REFCURSOR,    -- resultados
  p_code    OUT VARCHAR2,         -- 'OK' | 'ERR'
  p_message OUT VARCHAR2          -- detalle
) AS
  v_like   VARCHAR2(4000);
  v_num    NUMBER;
BEGIN
  -- Normaliza el patron LIKE (case-insensitive)
  v_like := '%' || LOWER(TRIM(p_search)) || '%';

  -- Intenta interpretar el mismo valor como numero (para id/price)
  BEGIN
    v_num := TO_NUMBER(REPLACE(TRIM(p_search), ',', '.')); -- soporta "12,34"
  EXCEPTION
    WHEN VALUE_ERROR THEN
      v_num := NULL; -- Si no es numero, no filtra por id/price
  END;

  OPEN p_result FOR
    SELECT
      p."id",
      p."name",
      p."description",
      p."price",
      p."image_path",
      p."category_id",
      c."name" AS "category_name"
    FROM "products" p
    LEFT JOIN "category" c ON c."id" = p."category_id"
    WHERE
         -- texto en name/description/categoria
         (LOWER(p."name") LIKE :b1
          OR LOWER(p."description") LIKE :b2
          OR LOWER(c."name") LIKE :b3)
      OR -- mismo parametro como numero: id o price
         (:b4 IS NOT NULL AND (p."id" = :b5 OR p."price" = :b6))
    ORDER BY
      -- orden simple por "relevancia" aproximada y luego por nombre
      CASE
        WHEN LOWER(p."name") LIKE :b7 THEN 0
        WHEN LOWER(c."name") LIKE :b8 THEN 1
        WHEN LOWER(p."description") LIKE :b9 THEN 2
        ELSE 3
      END,
      p."name"
  USING
    v_like, v_like, v_like,       -- b1..b3
    v_num, v_num, v_num,          -- b4..b6
    v_like, v_like, v_like;       -- b7..b9

  p_code    := 'OK';
  p_message := 'Busqueda ejecutada';
EXCEPTION
  WHEN OTHERS THEN
    p_code    := 'ERR';
    p_message := SQLERRM;
END;
/

CREATE OR REPLACE PROCEDURE sp_recalculate_order_totals (
  p_order_id IN  NUMBER,
  p_subtotal OUT NUMBER,
  p_discount OUT NUMBER,
  p_vat      OUT NUMBER,
  p_total    OUT NUMBER,
  p_code     OUT VARCHAR2,
  p_message  OUT VARCHAR2
) AS
  v_vat_percentage NUMBER(5,2);
BEGIN
  -- Subtotal desde las líneas
  SELECT NVL(SUM("quantity" * "unit_price"), 0)
    INTO p_subtotal
    FROM "order_details"
   WHERE "order_id" = p_order_id;

  -- Descuento e IVA guardados en la orden
  SELECT NVL("discount", 0), NVL("vat_percentage", 0)
    INTO p_discount, v_vat_percentage
    FROM "invoice"
   WHERE "purchase_order_id" = p_order_id;

  -- IVA calculado sobre (subtotal - descuento)
  p_vat := ROUND((p_subtotal - p_discount) * v_vat_percentage / 100, 2);

  -- Total usando la función reutilizable
  p_total := fn_calculate_order_total(p_order_id);

  -- Actualizar el total en la orden
  UPDATE "orders"
     SET "total_amount" = p_total
   WHERE "id" = p_order_id;

  -- Mensaje de éxito
  p_code    := 'OK';
  p_message := 'Totales recalculados';

EXCEPTION
  WHEN NO_DATA_FOUND THEN
    p_code    := 'ERR_NOT_FOUND';
    p_message := 'Orden no existe';
  WHEN OTHERS THEN
    p_code    := 'ERR';
    p_message := SQLERRM;
END;
/

CREATE OR REPLACE PROCEDURE sp_record_payment (
  p_amount            IN  NUMBER,
  p_date              IN  DATE,
  p_payment_method_id IN  NUMBER,   -- catÃ¡logo de mÃ©todos
  p_type              IN  VARCHAR2,
  p_payment_id        OUT NUMBER,
  p_code              OUT VARCHAR2,
  p_message           OUT VARCHAR2
) AS
BEGIN
  INSERT INTO "payments" ("amount", "date", "payment_method_id", "type")
  VALUES (p_amount, NVL(p_date, TRUNC(SYSDATE)), p_payment_method_id, p_type)
  RETURNING "id" INTO p_payment_id;

  p_code    := 'OK';
  p_message := 'Pago registrado';
EXCEPTION
  WHEN OTHERS THEN
    p_code    := 'ERR';
    p_message := SQLERRM;
END;
/

--===================
-- CONFIRMAR CAMBIOS
--===================
COMMIT;
/
